# 多线程

### 实现Runnable接口和Callable接口的区别
如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。

### sleep 和wait 区别
- sleep 没有释放锁 ，wait释放锁
- wait 用于线程间通讯 ,sleep 用于暂停执行
- wait 调用后线程不会自动苏醒，需要notify ,sleep 执行完成后线程会自动苏醒。

### 为什么我们调用start() 会执行run() ,而不能直接调用run()
 调用start() 会执行线程的相应的准备工作，然后其中的线程自动执行run();而直接调用run() 会把她当成main()下的普通方法，并不是多线程工作。

### ThreadLocal 
线程私有

每个THread 中都具备一个ThreadLocalMap ，而 ThreadLocalMap可以存储以ThreadLocal为Key的键值对。

#### ThreadLocal 内存泄露问题
ThreadLocalMap 􏰛􏱾􏱿使用的 key 为 􏰺 ThreadLocal 的弱引用􏼏􏱿,而􏲻 value是强引用。所以如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而value 不会被清理掉。这样一来,ThreadLocalMap 中出现了key 为null 的Entry。加入没有任何措施的话，value 永远不会被GC回收，这个时候会产生内存泄露。
最好使用完ThreadLocal后手动调用remove()方法。

## 如何创建线程池

阿里开发手册中强制线程池不允许使用 Executors去创建,而是通过 ThreadPoolExecutor 的方式，避免资源耗尽的风险。
Executors线程池对象弊端如下：
- FixedThreadPool 和SingleThreadPool 允许队列的长度为Integer.Max_value ，可能堆积大量的请求，导致OOM。
- CachedThreadPool 和 ScheduledThreadPool 允许创建的线程数量为 Integer.Max_value 可能创建大量线程 ，导致OOM 。

### ThreadPoolExecutor 重要参数 

- corePoolSize :核心线程数
- maximumPoolSize: 最大线程数
- workQueue: 达到最大线程数，会放到队列中

常见参数：
- keepAliveTime: 大于核心线程数 又没有新任务 等待时间

- unit：等待时间单位
- threadFactory 
- handler: 饱和策略

### 饱和策略 
- AbortPolicy： 抛异常
- CallerRUnsPolicy: 调用执行自己的线程运行任务,会降低新任务提交速度，影响性能，适合不能丢任务的请求。
- DiscardPolicy： 不处理新任务
- DiscardOldestPolicy: 丢弃最早的未处理的任务。

```aidl
class Demo {
 executor
 
 class runner{}
 
 executor.execute(runner)
 executor.shutdown();
}
```





