<h1>Elastic 原理篇</h1>
<h2>WHY</h2>

此文章参照 infoQ陶文大师的文章[时间序列数据库的秘密](https://www.infoq.cn/profile/1278798)  根据自己的理解整理的 

<h3>时间序列数据</h3>
* 1.第一类格式 
[metric_name] [timestamp] [value]
 ```
SELECT value FROM metric WHERE metric_name=”A” AND timestamp >= B AND 
 ```
这种模式两个弊端
* 1.无法快速响应变化: 如果需要的图表有变更，需要从上报的源头重新来一遍。而且要等新数据过来之后，才能查看这些新数据。
* 2.存储膨胀：总有一些数据是需要从不同的维度查询的需求，比如广告点击流数据，需要按省份聚合，按运营商聚合，按点击人喜好组合，这些维度交叉组合存储起来又会造成空间浪费。


<h3>如何快速检索？</h3>

几个概念： `document docid  term `
* term dictionary ：排好序的 term 
* term index : `类似于一本字典的章节列表` 标记了 term dictionay 位置（存储在磁盘中）  `体积小 存储在内存中`，
 term index 是 一个tree 树: term 可以是任意的 byte 数组，然后每个 index 大小不一 这棵树不会包含所有的 
 * term，它包含的是 term 的一些前缀。通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。再加上一些压缩技术（搜索 Lucene Finite State Transducers） term index 的尺寸可以只有所有 term 的尺寸的几十分之一
![avatar](https://static001.infoq.cn/resource/image/e4/26/e4599b618e270df9b64a75eb77bfb326.jpg)

<h3>ES 为什么比MySQL 快？</h3>

Mysql 只有 term dictionary 这一层，是以 b-tree 排序的方式存储在磁盘上的。检索一个 term 需要若干次的 random access 的磁盘操作。

1）Lucence 有 term index 加速检索 

2） 还有 存储在内存中 

3）term index 以树的形式缓存在内存中。

了解[FST](https://www.cnblogs.com/jiu0821/p/7688669.html)  
![avatar](https://images2017.cnblogs.com/blog/504727/201710/504727-20171018202211834-1358126860.jpg)

FST 为啥省内存??
   
   正因为，我们保证了所有的Key都是按照字典序加进来的，所以当加入一个新Key的时侯，我们可以先求出新加的Key和上一次输入的Key的公共前缀，然后就可以把 上一次输入的Key除去公共前缀剩下的部分存入文件中了。
   
如果想了解请查看Lucene4.0官方开源代码Builder.java 的add 方法。目前Lucene还支持FST的反映射，即通过Value找Key，以及前k小的Key（按照Value大小排序）。其实就是在FST上用`Dijikstra`求最短路。

额外值得一提的两点是：
* term index 在内存中是以 FST（finite state transducers）的形式保存的，其特点是非常节省内存。
* Term dictionary 在磁盘上是以分 block 的方式保存的，一个 block 内部利用公共前缀压缩（也是公共前缀压缩？），比如都是 Ab 开头的单词就可以把 Ab 省去。这样 term dictionary 可以比 b-tree 更节约磁盘空间。

<h3>如何联合索引查询？</h3>

所以给定查询过滤条件 age=18 的过程就是先从 term index 找到 18 在 term dictionary 的大概位置，然后再从 term dictionary 里精确地找到 18 这个 term，然后得到一个 posting list 或者一个指向 posting list 位置的指针。然后再查询 gender= 女 的过程也是类似的。最后得出 age=18 AND gender= 女 就是把两个 posting list 做一个`“与”`的合并。

如何合并两个 posting list 
1. 使用 skip list 数据结构。同时遍历 gender 和 age 的 posting list，互相 skip；
2. 使用 `bitset` 数据结构，对 gender 和 age 两个 filter 分别求出 bitset，对两个 bitset 做 AN 操作。
`PostgreSQL 从 8.4 版本开始支持通过 bitmap 联合使用两个索引，就是利用了 bitset 数据结构来做到的。`

**`Elasticsearch` 支持以上两种的联合索引方式，如果查询的 filter 缓存到了内存中（以 bitset 的形式），那么合并就是两个 bitset 的 AND。如果查询的 filter 没有缓存，那么就用 skip list 的方式去遍历两个 on disk 的 posting list。**

<h4>利用 Skip List 合并</h4>

![avatar](https://static001.infoq.cn/resource/image/ea/9f/eafa46683272ff1b2081edbc8db5469f.jpg)

1. 从小到大排序，取最短的开始，然后跳过其他比这个小的；
2. 跳跳跳
3. 原理 ？？？？自己写的 ，跳表原来好像不同 需要了解

多条序列
1. 从小到大排序，
2. 取最短一条序列开始
3. 确定多个序列的跳过位置0，确定初始值 （最短序列开始第一个值）
4. 比较，更新跳过位置(规则:最小于接近于初始值的各个序列) ，寻找匹配  ， 更新初始位置（规则:比较各个跳过位置，取最大值）
5. 重复4

Lucene 自然会对这个 block 再次进行压缩。其压缩方式叫做 `Frame Of Reference` 编码 _`Frame Of Reference？？？？是个啥`_




