# 索引

### 索引好处
关于MySQL索引的好处，如果正确合理设计并且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。

数据是存储在磁盘上的，操作系统读取磁盘的最小单位是页，如果没有索引，会加载所有的数据到内存，依次进行检索，加载的总数据会很多，磁盘IO多。

没有索引的情况下，不论是以主键还是其他列作为搜索条件，只能沿着页的双链表从左到右依次遍历各个页。

### 索引的类别
聚簇索引与非聚簇索引

主键索引和辅助索引(常规所指的索引，也叫二级索引，又分为唯一索引和非唯一索引。)

InnoDB引擎中，主键索引会被选中作为聚集索引，而唯一索引和普通辅助索引间除了唯一性约束外，在存储上没本质区别。

### MySQL索引演化
1.密集索引（Dense Index ）

根据减少无效数据访问的原则，我们将键的值拿过来存放到独立的块中。并且为每一个键值添加一个指针， 指向原来的数据块。

1.1折半块查找

需要对Dense进行索引，每个索引块内是有序的，另外，需要一个数组按顺序存储索引块地址，这样整体就有序了，数组也要存储到磁盘上，放在`单独的块链中`。折半查找的时间复杂度是O(log2(N))

2.稀疏索引（Sparse Index）

介绍基于块的折半查找时发现，读出每个块后只需要和第一行的键值匹配，就可以决定下一个块的位置（方向）。 因此有效数据是每个块的第一行数据，将每一个块的第一行的数据单独拿出来，和索引数组的地址放到一起。这样就可以直接在这个数组上进行折半查找了，这个数组就进化成了Sparse Index了。

3.多层稀疏索引

因为Sparse Index本身是有序的，所以可以为Sparse Index再建sparse Index。通过这个方法，一层一层的建立 Sparse Indexes,直到最上层的Sparse Index只占用一个块为止。
### 索引组成简述
   InnoDB数据页有7个部分组成，各个数据页可以组成一个双向链表，而每个数据页中的记录又可以组成一个单向链表，每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

![avatar](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5asGu0xrowZ97BFBFvrXsCs2ZSu49ZvFjk5fWLAflFSD2iadlbJkQicDQ/640)
##索引执行步骤简述

一个页中的查找

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

* 以主键为搜索条件

这个查找过程我们已经很熟悉了，可以在页目录中使用`二分法`快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

* 以其他列作为搜索条件

对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的`页目录`，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历`单链表`中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

在很多页中查找

由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上边已经唠叨过的查找方式去查找指定的记录。

一行的格式示意图

![avatar](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5dMTgZ8zvqoEax8dqq87xj59ywc2szJicaBsZkibTdnRx1icCtEYTDgRRQ/640)
我们只在示意图里展示记录的这几个部分：

**record_type**：记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1我们还没用过，等会再说～

**next_type**：记录头信息的一项属性，表示下一条地址的偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。

**各个列的值**：就是各个数据列的值，其中我们用橘黄色的格子代表c1列，深蓝色的格子代表c2列，红色格子代表c3列。

*其他信息*：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。



## 聚簇索引
概念:

![avatar](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt55ga3Fmqa9Hicn9CQ6Lh2ibT7chylHXd6C6RdrbmZdmFzZJiafyoyjyIjQ/640)

实际用户记录其实都存放在B+树的最底层的节点上

### 概念:
* 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
* 非聚簇索引(又叫`二级索引`)：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行

我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
 * 页内的记录是按照主键的大小顺序排成一个`单向链表`。

 * 各个存放用户记录的页也是根据页中记录的主键大小顺序排成一个`双向链表`。

 * 各个存放目录项的页也是根据页中记录的主键大小顺序排成一个`双向链表`。

2.B+树的叶子节点存储的是完整的用户记录。

  所谓完整的用户记录，就是指这个记录中存储了所有列的值。

我们把具有这两种特性的B+树称为聚簇索引

聚簇索引优点:

* 聚簇索引将索引和数据行保存在同一个B-Tree中，查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高。
* 聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的，

### 二级索引
除了除了聚簇索引之外的索引

二级索引这个B+树与聚簇索引有几处不同：

使用记录索引列的大小进行记录和页的排序，这包括三个方面的含义：

* 页内的记录是按照`索引列`的大小顺序排成一个单向链表。
  * 各个存放用户记录的页也是根据页中记录的`索引列`大小顺序排成一个双向链表。
  * 各个存放目录项的页也是根据页中记录的`索引列`大小顺序排成一个双向链表。
  * B+树的叶子节点存储的并不是完整的`一页记录`，而只是`索引列`+`主键`这两个列的值。

* 目录项记录中不再是主键+页号的搭配，而变成了`索引列`+`页号`的搭配。

### 二级索引查找过程
查找过程如下：
1. 确定目录项记录页
2. 通过目录项记录页确定用户记录真实所在的页。
3. 在真实存储用户记录的页中定位到具体的记录。
4. 但是这个B+树的叶子节点中的记录只存储了c2(索引列)和c1（也就是主键）两个列，所以我们必须再根据主键值`去聚簇索引中再查找一遍`完整的用户记录。 (**回表**)

#### 为啥回表？
你说的对，如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方了呀


### 联合索引

```其非叶子节点存储的是第一个关键字的索引，而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1、col2、col3的顺序进行排序。```

* 先把各个记录和页按照c2列进行排序。
* 在记录的c2列相同的情况下，采用c3列进行排序
![avatar](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5nXZJIREPnjDpcQ73cLseLFZLjF5bWTVHYp7TvME6jWVgI3zmhWoqhQ/640)

与分别为c2和c3列建立索引的表述是不同的，不同点如下：
* 建立联合索引只会建立如上图一样的1棵B+树。
* 为c2和c3列建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

### 覆盖索引

涉及二级索引，因为索引中有建立索引的值，查询条件正好是这些索引值得时候 就不用回表了，直接从二级索引中把索引值返回就好了，这种 叫做覆盖索引。

## MyISAM中的索引方案
MyISAM的索引方案虽然也使用B+树，但是却将索引和数据分开存储：

* 将表中的记录按照插入时间顺序的存储在`一块存储空间`上，我们可以通过行号而快速访问到一条记录（因为index_demo表的记录是`定长`的，所以可以使用行号来进行快速访问，对于变长的记录MyISAM有不同的处理方案，我们这里就不介绍了），如图所示： (**`哈希索引？？？`**)
![avatar](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5L11Q62nngFGjI1ZkhsQWE0f4wMXjnwI9YY480d17lG1wgfZib2gSaaw/640)

* 由于在插入数据的时候并`没有刻意按照主键大小排序`，所以我们并`不能`在这些数据上使用二分法进行查找。

* MyISAM会单独为表的主键创建一个`B+树`索引，只不过在B+树的叶子节点中存储的不是完整的用户记录，而是`主键值 + 行号`的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！

* 这一点和InnoDB是完全不相同的，在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找能找到对应的记录，而在MyISAM中却需要进行一次`回表`操作，意味着MyISAM中建立的索引全部都是`二级索引`！

* 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引是一样的，只不过在叶子节点处存储的是相应的列 + 行号而已。这些索引也全部都是`二级索引`。

### 为啥索引建多了不好
为啥不自动为每个列都建立个索引呢？别忘了，每建立一个索引都会`建立一棵B+树`，每插入一条记录都要维护各个记录、数据页的排序关系，这是`很费性能`和`存储空间`的。

### 

## 索引算法
### B+树
[基础内容链接 多叉平衡树](./每日一问0801(树).md)

#### 为什么索引采用B+树呢？

和SQL的需求相关。
一个单行查询的SQL，例如passport，确实可以使用哈希索引。
但是对于排序查询的SQL需求：

1. 分组：group by
2. 排序：order by
3. 比较：<、>

哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率。

哈希类型的索引，都要比树型的索引更快一些，那为什么，索引结构要设计成树型呢？

### 为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引？
### B+Tree比BTree做索引的优势？
### 为什么MongoDB采用B-Tree作为索引结构而MySQL采用B+Tree作为索引存储结构？



## mysql中建立索引的一些原则
* 先存数据，再建索引
* 不要对数据量小的数据表建立索引，数据量超过300的表应该有索引
* 对于规模小的数据表建立索引，不仅不会提高查询效率，相反使用索引查找可能比简单的全表扫描还要慢，而 且建索引还会占用一部分的存储空间
* 当对表的查询操作比更新操作频率更高时，对该表建立索引
* 在不同值较少的字段上不必要建立索引，如`性别`字段， `为啥？？？`
* 对查询操作中使用频繁的字段建立索引
* 表的主键、外键必须有索引
* 经常出现在Where后面的字段，特别是大表的字段，应该建立索引
* 经常进行GROUP BY、ORDER BY的字段上建立索引
* 索引应该建在小字段上，对于`大的文本字段甚至超长字段，不要建索引` `坏处？？？`


# 索引优化
- 多索引查询，区间长的放最左边，因为区间短的可能效率还不如全表扫描
- or in ,unin 都能命中索引 建议使用 in 
- 更新频繁的字段不宜使用索引，因为会更新二叉树
- 具有唯一特性的要建立唯一索引，及时是多个字段组合 并且影响Insert 性能，但索引的提升效率可见，并且增加了业务控制。
- 查询尽量不要使用*  减少回表。（有的查询可以直接从索引里取）
- 用explan 分析
- 内存碎片
- 调整数据页大小？（数据页默认16k,改8k查询效率好像快一点）
# 索引失效
- 当like为'%abc'会失效
- is null  is not null （索引是不索引空值的）
- 负向条件不会命中索引  （not，<>，!=）
- 不包含索引的放最前边，会导致后边有索引的也不会命中索引
-  or 语句前后没有都使用索引
- 数据类型发生隐式转换 ，如没加单引号，char 转成int 会全表扫描
- 字段上使用函数，不走索引(emp(name,pp,sal))
- 当全表扫描比索引速度快时，索引失效


## 参考
[MySQL的索引](https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&mid=2247486241&idx=1&sn=b9110c9d5be352f115c0d8cf6a0a520e&chksm=9bd0a6b9aca72faff0fe2f1ea1c3f43d6716f882bde357a999fe0094aa4e1f880f46473d1b98&scene=27#wechat_redirect)

[理解索引](https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&mid=2247484932&idx=1&sn=6819e1a80541e0e869cf61120aadbef4&chksm=fcaedc18cbd9550e317f1d258e8128a7894bd024c38f9829515cac3424b7d9eceb8ff76b35d9&scene=27#wechat_redirect)

[MongoDB 及 Mysql 背后的 B/B+树](https://www.cnblogs.com/morethink/p/9251530.html)
