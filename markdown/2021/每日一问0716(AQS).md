# AQS

### 抽象队列同步器

## 锁

Syncronized重入的实现原理
任意一把Syncronized锁对象，使用java -c xx.class 编译以后会产生两个指令monitorEnter和monitorExit，这两个指令代表锁的获取和锁的释放，多出来的monitorExit是程序异常的时候，可以正常的释放锁。
每个锁对象拥有一个锁计数器和一个指向持有该锁的线程指针当执行moniterenter时，如果目标锁对象的计数器为零，那么说明他没有被其他线程持有，java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1，在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么java虚拟机计数器可以加1否则需要等待，直至持有线程释放锁。当执行monitorexit时，java虚拟机则将锁对象的计数器减1，计数器为0说明锁已经释放
ReentrantLock可重入锁实现原理
实现加锁次数和释放锁次数不一致由于加锁次数和释放锁次数不一致，第二个线程始终无法获取到锁，导致一直等待正常情况下，加锁几次就要解锁几次.
ReentrantLock锁少释放的问题： 导致其他线程获取不到锁，程序会一直阻塞

#### AQS作用

- 加锁会导致阻塞，有阻塞就会排队，实现排队必然需要有某种形式的队列来进行管理

#### AQS的原理

AQS为实现阻塞锁，**依赖先进先出的一个等待依靠一个原子int值来表示状态**，通过占用和释放方法，改变状态值AQS使用一个volatile的int类型的成员变量来表示同步状态，**通过内置的FIFO队列来表示完成获取资源的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配**，通过CAS完成对State值得修改

#### AQS的变量

- state变量： 判断是否阻塞
  - 阻塞需要排队（前提：自旋如果达到一定时间），实现排队必须需要队列
- Node节点的变量
  - 队列中每个队列的个体也就是Node

## 参考

[深入理解 AQS 底层实现原理](https://blog.csdn.net/weixin_44624375/article/details/110133306)