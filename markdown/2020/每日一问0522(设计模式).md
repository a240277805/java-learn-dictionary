 # 设计模式

设计的六大原则：

 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。

 依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

 接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

 迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。

 ## 装饰者模式

## 策略模式

通过上文介绍的返奖业务模型，我们可以看到返奖的主流程就是选择不同的返奖策略的过程，每个返奖策略都包括返奖金额计算、更新用户奖金信息、以及结算这三个步骤。 我们可以使用**工厂模式生产出不同的策略**，同时使用策略模式来进行不同的策略执行。

工厂方法模式帮助我们直接产生一个具体的策略对象，策略模式帮助我们保证这些策略对象可以自由地切换而不需要改动其他逻辑，从而达到解耦的目的。通过这两个模式的组合，当我们系统需要增加一种返奖策略时，只需要实现RewardStrategy接口即可，无需考虑其他的改动。当我们需要改变策略时，只要修改策略的类名即可。不仅增强了系统的可扩展性，避免了大量的条件判断，而且从真正意义上达到了高内聚、低耦合的目的。

（规则引擎 可使用策略模式？）

## 观察者模式

kafka 进行消息监听 ，进行Topic 广播

## 责任链模式

模式定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。

例如: 订单 下单过程中看是否命中哪个活动，哪个优惠券，建立多个对象，对象之间通过某个方法进行调用传递，使多个对象都有机会处理请求，用责任链模式。

## 单例模式

## 工厂方法模式

定义一个创建对象的接口，让子类决定实例化那个类。

## 建造者模式



## 抽象工厂模式

## 原型模式

## 代理模式



## 参考

[设计模式在美团外卖营销业务中的实践](https://blog.csdn.net/fly910905/article/details/112371239?utm_term=%E4%B8%9A%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-2-112371239&spm=3001.4430)