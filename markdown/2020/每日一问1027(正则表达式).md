# 正则表达式

 正则表达式是一串字符，它描述了一个文本模式，利用它可以方便地处理文本，包括文本的查找、替换、验证、切分等

 正则表达式中的字符有两类：一类是普通字符，就是匹配字符本身；另一类是元字符，这些字符有特殊含义，这些元字符及其特殊含义构成了正则表达式的语法。

 最后针对转义、匹配模式和各种语法进行总结。
 1．单个字符大部分的单个字符就是用字符本身表示的，比如字符'0'、'3'、'a'、'马'等，但有一些单个字符使用多个字符表示，这些字符都以斜杠'\'开头，比如：

 1）特殊字符，比如tab字符'\t'、换行符'\n'、回车符'\r'等。

 2）八进制表示的字符，以\0开头，后跟1～3位数字，比如\0141，对应的是ASCII编码为97的字符，即字符'a'。

 3）十六进制表示的字符，以\x开头，后跟两位字符，比如\x6A，对应的是ASCII编码为106的字符，即字符'j'。

 4）Unicode编号表示的字符，以\u开头，后跟4位字符，比如\u9A6C，表示的是中文字符'马'，这只能表示编号在0xFFFF以下的字符，如果超出0ⅩFFFF，使用\x{...}形式，比如\x{1f48e}。

 5）斜杠\本身，斜杠\是一个元字符，如果要匹配它自身，使用两个斜杠表示，即'\\'。

 6）元字符本身，除了'\'，正则表达式中还有很多元字符，比如．、*、? 、+等，要匹配这些元字符自身，需要在前面加转义字符'\'，比如'\.'。

 2．字符组字符组有多种，包括任意字符、多个指定字符之一、字符区间、排除型字符组、预定义的字符组等，下面具体介绍。点号字符'.'是一个元字符，默认模式下，它匹配除了换行符以外的任意字符，

 比如正则表达式：a.f ,既匹配字符串"abf"，也匹配"acf" 一般称为单行匹配模式或者点号匹配模式  一种是在正则表达式中，以(? s)开头，s表示single line，即单行匹配模式。比如：(? s)a.f


在单个字符和任意字符之间，有一个字符组的概念，匹配组中的任意一个字符，用中括号[]表示，比如： [abcd] 匹配 a,b,c,d 中的任意一个字符

为方便表示连续的多个字符，字符组中可以使用连字符'-' 比如 [0-9a-zA-Z]

在字符组中，'-'是一个元字符，如果要匹配它自身，可以使用转义，即'\-'，或者把它放在字符组的最前面 [-0-9]

字符组支持排除的概念，在[后紧跟一个字符^[^abcd] 表示匹配除了a, b, c, d以外的任意一个字符

^只有在字符组的开头才是元字符，如果不在开头，就是普通字符，匹配它自身
[a^b] 匹配 a,^ 或b

### 有一些特殊的以\开头的字符，表示一些预定义的字符组，比如：

❑ \d:d表示digit，匹配一个数字字符，等同于[0-9]。

❑ \w:w表示word，匹配一个单词字符，等同于[a-zA-Z_0-9]。

❑ \s:s表示space，匹配一个空白字符，等同于[ \t\n\x0B\f\r]。

它们都有对应的排除型字符组，用大写表示，即：

❑ \D：匹配一个非数字字符，即[^\d]。

❑ \W：匹配一个非单词字符，即[^\w]。

❑ \S：匹配一个非空白字符，即[^\s]。

还有一类字符组，称为POSIⅩ字符组，它们是POSIⅩ标准定义的一些字符组

## 3。 量词

量词指的是指定出现次数的元字符，有三个常见的元字符：+、*、? ：

1）+：表示前面字符的一次或多次出现，比如正则表达式ab+c，既能匹配abc，也能匹配abbc，或abbbc。

2）*：表示前面字符的零次或多次出现，比如正则表达式ab*c，既能匹配abc，也能匹配ac，或abbbc。

3）? ：表示前面字符可能出现，也可能不出现，比如正则表达式ab? c，既能匹配abc，也能匹配ac，但不能匹配abbc。

更为通用的表示出现次数的语法是{m, n}，出现次数从m到n，包括m和n，如果n没有限制，可以省略，如果m和n一样，可以写为{m}，比如：

❑ ab{1,10}c:b可以出现1次到10次。

❑ ab{3}c:b必须出现三次，即只能匹配abbbc。

❑ ab{1, }c：与ab+c一样。

❑ ab{0, }c：与ab*c一样。

❑ ab{0,1}c：与ab? c一样。

?、*、+、{是元字符，如果要匹配这些字符本身，需要使用'\'转义，比如：a\*b


关于量词，它们的默认匹配是贪婪的，什么意思呢？看个例子，正则表达式是：

<a>.*</a>
处理 
<a>first</a><a>second</a>
得到 <a>first</a><a>second</a> 

目的是得到   <a>first</a> 和 <a>second</a>

这是因为．*可以匹配第一个<a>和最后一个</a>之间的所有字符，只要能匹配，.*就尽量往后匹配，它是贪婪的。如果希望在碰到第一个匹配时就停止呢？应该使用懒惰量词，在量词的后面加一个符号'? '
针对上例，将表达式改为：<a>.*?</a>

## 4. 分组

表达式可以用括号()括起来，表示一个分组，比如a(bc)d, bc就是一个分组。分组可以嵌套，比如a(de(fg))。分组默认都有一个编号，按照括号的出现顺序，从1开始，从左到右依次递增，比如表达式：

a(bc)((de)(fg))

字符串abcdefg匹配这个表达式，第1个分组为bc，第2个为defg，第3个为de，第4个为fg。分组0是一个特殊分组，内容是整个匹配的字符串，这里是abcdefg。分组匹配的子字符串可以在后续访问，好像被捕获了一样，所以默认分组称为捕获分组。关于如何在Java中访问和使用捕获分组，


可以对分组使用量词，表示分组的出现次数，比如a(bc)+d，表示bc出现一次或多次。

括号()和元字符'|'一起，可以表示匹配其中的一个子表达式 (http|ftp|file)

| 用于[] 中不再有特殊含义 如[a|b] 匹配 a或|或b

在正则表达式中，可以使用斜杠\加分组编号引用之前匹配的分组，这称为回溯引用，比如：<(\w+)>(.*)</\1>  \1匹配之前的第一个分组(\w+)，这个表达式可以匹配类似如下字符串：
<title>bc</title>

## 5. 特殊边界匹配

在正则表达式中，除了可以指定字符需满足什么条件，还可以指定字符的边界需满足什么条件，或者说匹配特定的边界，常用的表示特殊边界的元字符有^、$、\A、\Z、\z和\b。

默认情况下，^匹配整个字符串的开始，^abc表示整个字符串必须以abc开始。

需要注意的是^的含义，在字符组中它表示排除，但在字符组外，它匹配开始，比如表达式^[^abc]，表示以一个不是a、b、c的字符开始。

默认情况下，$匹配整个字符串的结束，不过，如果整个字符串以换行符结束，$匹配的是换行符之前的边界，比如表达式abc$，表示整个表达式以abc结束，或者以abc\r\n或abc\n结束。

以上^和$的含义是默认模式下的，可以指定另外一种匹配模式：多行匹配模式，在此模式下，会以行为单位进行匹配，^匹配的是行开始，$匹配的是行结束，比如表达式是^abc$，字符串是"abc\nabc\r\n"，就会有两个匹配。

可以有两种方式指定匹配模式。一种是在正则表达式中，以(? m)开头，m表示multi-line，即多行匹配模式，上面的正则表达式可以写为：(? m)^abc$

需要说明的是，多行模式和之前介绍的单行模式容易混淆，其实，它们之间没有关系。单行模式影响的是字符'.'的匹配规则，使得'.'可以匹配换行符；多行模式影响的是^和$的匹配规则，使得它们可以匹配行的开始和结束，两个模式可以一起使用。 

\A与^类似，但不管什么模式，它匹配的总是整个字符串的开始边界。

\Z和\z与$类似，但不管什么模式，它们匹配的总是整个字符串的结束边界。\Z与\z的区别是：如果字符串以换行符结束，\Z与$一样，匹配的是换行符之前的边界，而\z匹配的总是结束边界。在进行输入验证的时候，为了确保输入最后没有多余的换行符，可以使用\z进行匹配。

\b匹配的是单词边界，比如\bcat\b，匹配的是完整的单词cat，它不能匹配category。\b匹配的不是一个具体的字符，而是一种边界，这种边界满足一个要求，即一边是单词字符，另一边不是单词字符。在Java中，\b识别的单词字符除了\w，还包括中文字符。

## 参考地址：

* [java的编程逻辑](https://weread.qq.com/web/reader/b51320f05e159eb51b29226ka8b3222028ea8baa56554b9)

