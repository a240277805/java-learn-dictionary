# 规则引擎


我们接到一个折扣策略需求，针对于某些应用使用更低的折扣。而且总会有类似的需求，比如某些应用不能使用该折扣，某范围内的应用可以使用，或者是多重条件某些应用 和某些服务商可以应用特定折扣等等。
```aidl
when 条件A then  
     条件B then 
     条件C then 
     条件D then
     条件E&&条件F then 
    条件G||条件I then
```
## 为什么需要规则引擎
我们之前的解决方案：
由于考虑到时间成本和实现复杂度，就直接在代码里硬编码，这样做的优点：
- 可以快速实现产品功能，时间成本低
- 实现难度低
缺点:
- 针对于频繁变更的需求，每次都需要重新编码
- 多次实现不同的逻辑，时间久了 分支太多 不好维护(可以用策略设计模式)
- 每种策略都有自己的编写格式，可读性差
- 碰到有冲突的策略，重构难度高
- 每次要重新部署

我们讨论了一番，有人说考虑一下存储过程，将变化的策略放在存储过程里维护，这样至少修改了策略，不用部署原来的应用！但有人回了一句:"不行！不行！用存储过程可读性更差，而且性能还不好！更可怕的是，如果你用的是MySQL，调试存储过程是会要人命的！"

后来我们整理了一下**需求**:
- 简化策略结构，让业务逻辑和数据分离!
- 分离出的业务逻辑必须要易于编码，至少单独编写这些业务逻辑，要比写代码快！
- 分离出的业务逻辑必须要比原来代码更容易读懂!
- 分离出的业务逻辑必须比原来的易于维护，至少改动这些逻辑，应用不需要重启。

大家问道"有满足这样需求的中间件么？"

有的，那就是 *规则引擎*!
## 什么是规则引擎
### 产生背景
企业级管理者可能会在系统生产过程中调整生产策略、物料采购策略等，因此对企业IT系统的开发有着如下的要求：

- 为提高效率，管理流程必须自动化，即使现代商业规则异常复杂。
- 市场要求业务规则经常变化，IT系统必须依据业务规则的变化快速、低成本的更新。
- 为了快速、低成本的更新，业务人员应能直接管理IT系统中的规则，不需要程序开发人员参与。

而项目开发人员则碰到了以下问题:

- 程序=算法+数据结构，有些复杂的商业规则很难推导出算法和抽象出数据模型
- 软件工程要求从需求->设计->编码，然而业务规则常常在需求阶段可能还没有明确，在设计和编码后还在变化，业务规则往往嵌在系统各处代码中
- 对程序员来说，系统已经维护、更新困难，更不可能让业务人员来管理。

因此迫切需要分离商业决策者的商业决策逻辑和应用开发者的技术决策。把这些商业决策放在中心数据库或其他统一的地方，让它们能在运行时（即商务时间）可以动态地管理和修改从而提供软件系统的柔性和适应性。

### 定义
规则引擎由推理引擎发展而来，是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据规则做出业务决策。
### 原理
规则引擎可以在系统工作时，*将外部的业务规则加载到系统中*，并使得系统按照该业务规则进行工作。接下来我们分别进行介绍。
注: 如果之前的场景可能是在数据库层做的筛选，那规则引擎是需要将所有规则 加载到*内存*中去运行规则，他更多的是逻辑运算，所以说 规则引擎的项目是一个CPU密集型应用，最好是单独部署，和常见的IO密集型应用分开。

### *****基本概念
#### 业务规则 (rule)
一个业务规则包含一组条件和在此条件下执行的操作，它们表示业务规则应用程序的一段业务逻辑。业务规则通常应该由业务分析人员和策略管理者开发和修改，但有些复杂的业务规则也可以由技术人员使用面向对象的技术语言或脚本来定制。业务规则的理论基础是:*设置一个或多个条件，当满足这些条件时会触发一个或多个操作。*
#### 规则引擎 (engine)
规则引擎 就像容器,是将数据 在规则中运行的逻辑，它至少包含以下API:
- 加载和卸载规则集的API；
- 数据操作的API；
- 引擎执行的API。

规则与规则之间如何执行，这个涉及到规则属性的定义，用于修改和增强标准的规则行为。
- 优先级（salience）：可以设置规则执行顺序，优先级高的优先执行
- 同步分组（agenda-group）： 同一个分组的规则要么都执行要么都不执行
- 互斥分组（activation-group）：同一个分组只有一条被执行，其他不执行


#### 事实 数据(facts)
也就是你要进行运行规则的数据。
## 规则引擎选型

| 名称 | github start  |  github地址|
| ---     |   ---     | --- |
| drools  | * 3.1k    | https://github.com/kiegroup/drools |
|easy-rules|* 2.4k    | https://github.com/j-easy/easy-rules |
|Aviator  | * 1.8K    | https://github.com/killme2008/aviator |
|MVEL      |* 703     | |

drools 特点
1. 完整的实现了Rate算法；
2. 提供了强大的Eclipse Plugin开发支持；
3. 通过使用其中的DSL(Domain Specific Language)，可以实现用自然语言方式来描述业务规则，使得业务分析人员也可以看懂业务规则代码；
4. 提供了基于WEB的BRMS——Guvnor，Guvnor提供了规则管理的知识库，通过它可以实现规则的版本控制，及规则的在线修改与编译，使得开发人员和系统管理人员可以在线管理业务规则。

easy-rules的特点
1. 轻量级类库和容易上手
2. 基于POJO的开发与注解的编程模型
3. 基于MVEL表达式的编程模型（适用于极简单的规则，一般不推荐）
4. 支持根据简单的规则创建组合规则
5. 方便且适用于java的抽象的业务模型规则

个人理解 ，drools 适合做海量多级规则的业务场景 
```aidl
规则流程
when A then
          when a1 then
          when a2 then  
     B then 
          when  b1 then
          when  b2 then
     C then
          when  c1 then
          when  c2 then
```
，原因是它有特定的编程语法(DSL)会增加一定的学习成本，如果是海量频繁规则变动维护的场景这些投入是可接受的，第二点是完整实现了Rate 算法，在海量规则，还有多级规则中有一定的优化。

easy-rules 更轻量，和自定义，只给出了规则引擎的概念，可以按照自己的理解和业务去设计符合的规则引擎，优点是容易上手，很低的投入引入规则引擎模块，自定义性强，但是缺点是规范性差，通用性取决于自己的设计。

## 规则引擎架构

一、 简单架构 

1. 直接业务代码中嵌入
2. 规则通过引入外部模板形式
3. 运行时加载规则，进行计算

二、 优化
1. 由于是CPU密集型应用 ，可以独立出来单独部署，对外提供服务
2. 加载规则的方式，可以改成动态加载 ，自定义规则模板 ，模板数据保存在 JSON，XML，数据库中
3. 规则引擎在内存中 对数据进行规则匹配，由于规则的变化性不大，可以将动态生成的规则放入缓存，更新的时候，同时更新缓存

三、参考美团 Maze 框架
1. MazeQL核心主要由3部分构成：配置中心、MazeQL引擎和平台。
![avatar](https://p0.meituan.net/travelcube/7119b70635731c94f45871ad788a3289400155.png)
2. 规则配置
![avatar](https://p1.meituan.net/travelcube/b648dab4d847848593cac4fa18c1cbf9212164.png)

具体可参考 美团技术文档 : [从0到1：构建强大且易用的规则引擎](https://tech.meituan.com/2017/06/09/maze-framework.html)
## easy-rules 概念

## 规则引擎 应用场景